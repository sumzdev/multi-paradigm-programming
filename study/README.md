# 멀티패러다임 프로그래밍

객체지향, 함수형, 명령형의 통합적 사고로 구현하는 소프트웨어 설계와 구현

**목차 (Table of Contents)**

## 0. 서론 및 개요

---

## [1장] 멀티패러다임이 현대 언어를 확장하는 방법 (28)
* **1.1 객체지향 디자인 패턴의 반복자 패턴과 일급 함수** (39)
    * 1.1.1 GoF의 반복자 패턴 (39)
    * 1.1.2 ArrayLike로부터 Iterator 생성하기 (41)
    * 1.1.3 ArrayLike를 역순으로 순회하는 이터레이터 만들기 (43)
    * 1.1.4 지연 평가되는 map 함수 (45)
    * 1.1.5 멀티패러다임의 교차점: 반복자 패턴과 일급 함수 (47)
* **1.2 명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수** (49)
    * 1.2.1 제너레이터 기본 문법 (49)
    * 1.2.2 제너레이터로 작성한 reverse 함수 (53)
* **1.3 자바스크립트에서 반복자 패턴 사례: 이터레이션 프로토콜** (55)
    * 1.3.1 이터레이터와 이터러블 (55)
    * 1.3.2 언어와 이터러블의 상호작용 (61)
    * 1.3.3 제너레이터로 만든 이터레이터도 이터러블 (65)
* **1.4 이터러블을 다루는 함수형 프로그래밍** (67)
    * 1.4.1 forEach 함수 (67)
    * 1.4.2 map 함수 (69)
    * 1.4.3 filter 함수 (71)
    * 1.4.4 고차 함수 조합하기 (74)
    * 1.4.5 재미난 filter (75)
* **1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유** (77)
    * 1.5.1 Web API의 NodeList도 이터러블 (77)
    * 1.5.2 상속이 아닌 인터페이스로 해결해야 하는 이유 (79)
    * 1.5.3 인터페이스와 클래스 상속 (82)
* **1.6 요약정리** (84)

---

## [2장] 함수형 프로그래밍과 타입 시스템 그리고 LISP (87)
* **2.1 타입 추론과 함수 타입 그리고 제네릭** (89)
    * 2.1.1 타입 추론 (89)
    * 2.1.2 함수 타입과 제네릭 (94)
* **2.2 멀티패러다임 언어에서 함수형 타입 시스템** (98)
    * 2.2.1 이터레이션 프로토콜과 타입 다시 보기 (98)
    * 2.2.2 함수형 고차 함수와 타입 시스템 (99)
    * 2.2.3 함수 시그니처와 중첩된 함수들의 타입 추론 (107)
* **2.3 멀티패러다임 언어와 메타프로그래밍 — LISP로부터** (109)
    * 2.3.1 Pipe Operator (109)
    * 2.3.2 클래스와 고차 함수, 반복자, 타입 시스템을 조합하기 (111)
    * 2.3.3 LISP(클로저)에서 배우기 — 코드가 데이터, 데이터가 코드 (118)
    * 2.3.4 클로저에서 map이 실행될 때 (120)
    * 2.3.5 멀티패러다임 언어에서 사용자가 만든 클래스를 리스트로 만들기 (122)
    * 2.3.6 LISP의 확장성 — 매크로와 메타프로그래밍 (123)
    * 2.3.7 런타임에서 동적으로 기능 확장하기 (128)
    * 2.3.8 언어를 확장하는 즐거움 (134)
* **2.4 요약정리** (136)

---

## [3장] 코드:객체:함수 = Generator Iterator:LISP = IP:OOP:FP (141)
* **3.1 코드가 곧 데이터 — 로직이 담긴 리스트** (142)
    * 3.1.1 [for, i++, if, break] — 코드를 리스트로 생각하기 (142)
    * 3.1.2 현대 언어에서 리스트 프로세싱 (150)
    * 3.1.3 언어를 넘어 적용 가능한 개념, 패러다임 (155)
* **3.2 하스켈로부터 배우기** (156)
    * 3.2.1 하스켈의 함수와 함수 시그니처 (156)
    * 3.2.2 언어 차원에서 지원하는 커링 (157)
    * 3.2.3 main 함수와 IO (158)
    * 3.2.4 head, map, filter, foldl 함수 시그니처 (160)
    * 3.2.5 함수 합성 — `.` 연산자와 `$` 연산자 (162)
    * 3.2.6 sumOfSquaresOfOddNumbers 함수 (163)
    * 3.2.7 파이프라인 스타일 — `&` (164)
    * 3.2.8 Either를 통한 에러 처리 (164)
    * 3.2.9 패턴 매칭 (165)
* **3.3 지연 평가 자세히 살펴보기** (168)
    * 3.3.1 중첩된 이터레이터의 실행 순서 — 제너레이터로 확인하기 (168)
    * 3.3.2 자세히 살펴보기 (171)
    * 3.3.3 이터레이터로 직접 살펴보기 (173)
    * 3.3.4 단순화해서 살펴보기 (175)
* **3.4 Generator Iterator: LISP — 지연 평가와 안전한 합성** (177)
    * 3.4.1 find 함수 시그니처 (177)
    * 3.4.2 하스켈에서 find 함수와 안전한 합성 (178)
    * 3.4.3 find 함수로 생각하는 지연 평가와 리스트 프로세싱 (179)
    * 3.4.4 타입스크립트에서의 안전한 합성 (184)
    * 3.4.5 every 함수 (186)
    * 3.4.6 some 함수 (188)
    * 3.4.7 지연 평가에 기반한 break 로직 끼워 넣기 (190)
    * 3.4.8 every와 some 함수의 공통 로직을 함수형으로 추상화하기 (191)
    * 3.4.9 concat으로 더하기 (192)
* **3.5 요약정리** (199)

---

## [4장] 비동기 프로그래밍 (202)
* **4.1 값으로 다루는 비동기** (203)
    * 4.1.1 Promise (203)
    * 4.1.2 new Promise()를 직접 사용해본 적 있는가 (207)
    * 4.1.3 Promise.race (209)
    * 4.1.4 IO 작업에 타임아웃 설정하기 (209)
    * 4.1.5 응답 속도에 따라 다른 전략으로 UI 렌더링하기 (210)
    * 4.1.6 Promise.all (213)
    * 4.1.7 Promise.allSettled (214)
    * 4.1.8 Promise.any (216)
* **4.2 지연성으로 다루는 비동기** (218)
    * 4.2.1 Promise 실행을 지연하려면 (218)
    * 4.2.2 ChatGPT가 명령형으로 구현한 동시성 핸들링 함수 (224)
    * 4.2.3 함수형으로 구현한 동시성 핸들링 함수 (226)
    * 4.2.4 효과적인 비동기 핸들링으로 가는 계단 — 지연성 (229)
* **4.3 타입으로 다루는 비동기** (232)
    * 4.3.1 AsyncIterator, AsyncIterable, AsyncGenerator 프로토콜 (232)
    * 4.3.2 AsyncIterable을 다루는 고차 함수 (238)
    * 4.3.3 동기와 비동기를 동시에 지원하는 함수로 만드는 규약 — toAsync (243)
    * 4.3.4 타입 시스템 + 비동기 함수형 함수 + 클래스 (252)
* **4.4 비동기 에러 핸들링** (262)
    * 4.4.1 여러 이미지를 불러와서 높이 구하기 (262)
    * 4.4.2 개선된 비동기 로직 (264)
    * 4.4.3 에러가 제대로 발생하도록 하는 것이 핵심 (265)
    * 4.4.4 안정적인 소프트웨어와 비동기 프로그래밍 (268)
* **4.5 요약정리** (269)

---

## [5장] 실전 함수형 프로그래밍 (272)
* **5.1 실전 데이터 다루기** (273)
    * 5.1.1 2차원 배열에서 숫자 다루기 (273)
    * 5.1.2 농구팀 데이터 다루기 (274)
    * 5.1.3 커머스 데이터 다루기 (276)
    * 5.1.4 커머스 데이터 다루기 2 (279)
    * 5.1.5 일관된 접근 방식으로 문제 해결하기 (284)
* **5.2 더 많은 문제에 적용하기** (285)
    * 5.2.1 pipe 함수 (285)
    * 5.2.2 pipe와 비동기 함수 합성 (289)
    * 5.2.3 zip 함수 (290)
    * 5.2.4 인덱스가 값으로 필요할 때 (293)
    * 5.2.5 콜라츠 추측 — 1이 될 때까지 세기 (295)
    * 5.2.6 break를 대신하는 take, takeWhile, takeUntilInclusive (299)
    * 5.2.7 함수의 조합으로 만들어내는 로직 (302)
* **5.3 백엔드 비동기 프로그래밍** (303)
    * 5.3.1 커머스 플랫폼의 결제 프로세스 문제 (303)
    * 5.3.2 결제 내역 동기화 스케줄러 만들기 (304)
    * 5.3.3 해시 기반 접근으로 시간 복잡도 최적화 (316)
    * 5.3.4 안정적인 비동기 작업 간격 유지 (317)
    * 5.3.5 최대 요청 크기 제한을 효과적으로 처리하기 (319)
    * 5.3.6 사전 카운트로 효율 높이기 (321)
    * 5.3.7 병렬성으로 효율 높이기 (324)
    * 5.3.8 리스트 프로세싱 기반 비동기/동시성 프로그래밍 (327)
* **5.4 리스트 프로세싱 패턴화** (329)
    * 5.4.1 변형 패턴 (329)
    * 5.4.2 중첩-변형 패턴 (332)
    * 5.4.3 반복자-효과 패턴 (337)
    * 5.4.4 필터-중단 패턴 (339)
    * 5.4.5 무한-중단 패턴 (340)
    * 5.4.6 분할-평탄 패턴 (342)
    * 5.4.7 변형-평탄 패턴 (342)
    * 5.4.8 결합-순차적 패턴 (344)
    * 5.4.9 해시-매치 패턴 (345)
    * 5.4.10 리스트 프로세싱 함수 유형별 개념 정리 (348)
* **5.5 요약정리** (350)

---

## [6장] 멀티패러다임 프로그래밍 (354)
* **6.1 HTML 템플릿 엔진 만들기** (355)
    * 6.1.1 Tagged Templates (355)
    * 6.1.2 리스트 프로세싱으로 구현하기 (356)
    * 6.1.3 push를 concat으로 (358)
    * 6.1.4 XSS 공격 방지 (359)
    * 6.1.5 중첩 데이터 처리로 컴포넌트 방식 개발 지원하기 (362)
    * 6.1.6 구조의 문제는 객체지향으로, 로직의 문제는 함수형으로 해결하기 (364)
    * 6.1.7 배열로부터 html 문자열 만들기 (366)
    * 6.1.8 객체를 함수형으로 더하기 (368)
    * 6.1.9 배열 처리를 클래스 내부로 이동하여 편의성 높이기 (369)
    * 6.1.10 고차 함수로 추상화하기 (371)
    * 6.1.11 작은 프런트엔드 개발 라이브러리 만들기 (374)
    * 6.1.12 멀티패러다임 언어가 제시하는 기회 (378)
* **6.2 멀티패러다임을 활용한 동시성 핸들링** (379)
    * 6.2.1 executeWithLimit 다시 보기 (379)
    * 6.2.2 ChatGPT가 명령형으로 구현한 동시성 핸들링 함수 (381)
    * 6.2.3 멀티패러다임으로 구현한 동시성 핸들링 함수 (384)
    * 6.2.4 동시성(부하) 크기를 동적으로 변경할 수 있도록 확장하기 (387)
    * 6.2.5 무한 반복되는 작업의 부하 조절하기 (389)
    * 6.2.6 runAllSettled 추가하기 (391)
* **6.3 요약정리** (397)

---

## [7장] 객체지향 프런트엔드 개발 그리고 멀티패러다임적 접근과 응용 (401)
* **7.1 Setting 앱 만들기** (402)
    * 7.1.1 SwitchView (403)
    * 7.1.2 SettingItemView (405)
    * 7.1.3 SettingListView (407)
    * 7.1.4 SettingPage (408)
    * 7.1.5 전체 토글 기능 추가하기 (410)
    * 7.1.6 객체 간 통신과 커스텀 이벤트 디스패치 (413)
    * 7.1.7 이벤트 루프와 부수 효과의 발생 (420)
    * 7.1.8 타입 안전한 커스텀 이벤트 통신 패턴 (425)
    * 7.1.9 재사용 가능한 컴포넌트 SwitchView (427)
    * 7.1.10 패러다임이 만드는 리액티브한 코드 (428)
* **7.2 Todo 앱 만들기** (431)
    * 7.2.1 CheckView (431)
    * 7.2.2 추상 클래스와 상속 (433)
    * 7.2.3 Headless UI (434)
    * 7.2.4 TodoItemView (435)
    * 7.2.5 계층적 캡슐화 (437)
    * 7.2.6 TodoListView (438)
    * 7.2.7 제네릭 클래스로 추상화 (439)
    * 7.2.8 TodoPage (445)
    * 7.2.9 인터페이스에 기반한 객체 간 통신으로 중복 제거하기 (447)
    * 7.2.10 GoF의 디자인 패턴 관점 - 전략 패턴 (458)
    * 7.2.11 일급 함수를 활용한 객체 간 통신 - 콜백 인젝션 패턴 (459)
    * 7.2.12 멀티패러다임적인 코드 설계 (462)
* **7.3 Todo 앱 만들기 2** (464)
    * 7.3.1 데코레이터로 코드를 간결하게 (464)
    * 7.3.2 TextSubmitView (471)
    * 7.3.3 ListView에 헬퍼 메서드 추가하기 (472)
    * 7.3.4 새로운 Todo 생성하기 (473)
    * 7.3.5 SegmentControlView (475)
    * 7.3.6 휴리스틱 기반 Diff로 DOM 업데이트 최적화 (481)
* **7.4 Todo 앱 만들기 3** (486)
    * 7.4.1 상태 패턴으로 유연하게 만들기 (486)
    * 7.4.2 상태 패턴 적용의 이점 (489)
    * 7.4.3 런타임에서도 변경 가능한 코드와 소프트웨어 동작 (490)
    * 7.4.4 상태 객체로 더 확장하기 (492)
    * 7.4.5 멀티패러다임 객체지향 설계 (495)
* **7.5 비동기와 UI, Promise와 Class** (500)
    * 7.5.1 Promise를 활용한 Alert, Confirm (500)
    * 7.5.2 값으로서의 Promise, 컴포넌트 간 통신 매개 (503)
    * 7.5.3 그룹 채팅에 참여할 친구 선택하기 (505)
