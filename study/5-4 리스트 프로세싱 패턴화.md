# 리스트 프로세싱 패턴화

리스트 프로세싱의 다양한 조합을 좀더 구조적으로 이해할 수 있도록 패턴화된 몇 가지 사례를 소개합니다.

## (1) 변형-누적(map-reduce) 패턴

변형-누적(map-reduce) 패턴은 가장 널리 사용되는 패턴으로, 초기 이터러블을 map으로 변경한 뒤 reduce로 누적하여 최종 결과를 도출하는 방식이다.

- 프로그램의 결과물이 단일 값일 때 주로 사용 (배열이 아닌 객체, 숫자, 문자열 등으로 데이터를 변환하는 데 적합)
- 데이터 집계나 변환, 누적 작업애 매우 유용

### 상품의 총 수량

상품 목록에서 각 상품의 수량을 추출(변경)한 뒤 이를 누적하여 전체 수량을 계산한다.

```tsx
const totalQuantify = products =>
  products.map(product => product.quantity).reduce((a, b) => a + b, 0);
```

### Query String을 객체로 변환하기

Query String은 &로 구분된 키-값 쌍의 문자열 데이터로 이를 객체로 변환하면 각 키와 값이 속성으로 매핑된다.

```tsx
const queryString = 'name=Marty%20Yoo&age=41&city=Seoul';

const queryObject = queryString
  .split('&')
  .map(param => param.split('='))
  .map(entry => entry.map(decodeURIComponent))
  .map(([key, val]) => ({ [key]: val }))
  .reduce((a, b) => Object.assign(a, b), {});

console.log(queryObject);
// {name: "Marty Yoo", age: "41", city: "Seoul"}
```

### 객체를 Query String으로 변환하기

변형-누적 패턴을 사용하여 객체의 키-값 쌍을 Query String으로 변환한다. 이 패턴에서 map은 데이터를 변형하며 reduce는 각 요소를 순회하여 최종 결과를 누적한다. 객체의 키-값 쌍은 Query String 형태로 직렬화된다.

```tsx
const params = { name: 'Marty Yoo', age: '41', city: 'Seoul' };
```

```tsx
const queryString = Object.entries(params)
  .map(entry => entry.map(encodeURIComponent))
  .map(([key, value]) => `${key}=${value}`)
  .reduce((a, b) => `${a}&${b}`);

console.log(queryString);
// "name=Marty%20Yoo&age=41&city=Seoul"
```

join은 배열을 문자열로 변환할 때 사용하며 배열의 값들을 더하면서 그 사이에 separator를 삽입하다. 본질적으로 join은 reduce로 구현할 수 있는 동작을 추상화한 함수이다.

```tsx
const queryString2 = Object.entries(params)
  .map(entry => entry.map(encodeURIComponent))
  .map(entry => entry.join('='))
  .join('&');

console.log(queryString2);
// "name=Marty%20Yoo&age=41&city=Seoul"
```

커링과 파이프를 이용하여 동일한 코드를 더 간결하게 표현할 수 있다.

```tsx
const queryString3 = pipe(
  Object.entries(params),
  map(map(encodeURIComponent)),
  map(join('=')),
  join('&'),
);

console.log(queryString3);
// "name=Indong%20Yoo&age=41&city=Seoul"
```

## (2) 중첩-변형(nested-map) 패턴

리스트 프로세싱에서 중첩된 데이터 구조를 처리하거나 데이터의 계층을 따라 각 수준에서 변형을 수행할 때 사용하는 패턴이다.

- 트리 구조나 2차원 배열 등 계층적인 데이터를 변형하거나 처리할 때 매우 유용

TODO: p332

### 트리 구조 변형

### 달력 그리기(2차원 배열 join)

### 1) renderCalendar 함수

### 2) generateCalendar 함수

### 3) formatCalendar 함수

## (3) 반복자-효과(Iterator-forEach) 패턴

반복자-효과(Iterator-forEach) 패턴은 리스트 프로세싱에서 이터레이터를 만들어둔 후 지연 평가를 통해 데이터를 소비하며 부수적인 효과(forEach)를 발생시키는 패턴이다.

- 주로 데이터를 변형하거나 가져온 후 하나씩 소비하면서 특정 작업(예: 로깅, 출력, 네트워크 요청 등)을 수행할 때 사용됨
- 패턴의 결과로 최종 결과로 최종 데이터는 생성되지 않으며 작업 자체가 목적이 되는 경우에 적합하다.

TODO: p337

### 콘솔 출력으로 로그 남기기

### 결제 동기화 스케줄러 코드

### 부수 효과를 격리하는 forEach

## (4) 필터-중단(filter-take) 패턴

필터-중단(filter-take) 패턴은 리스트 프로세싱에서 데이터를 조건에 따라 필터링한(filter) 후 일부 데이터만 선택하여(take) 소비하는 패턴이다.

- 대규모에서 특정 조건을 만족하는 일부 데이터만 빠르게 추출해야 할 때 유용하다.
- 데이터를 필요한 만큼만 처리하고 조건을 만족한 시점의 이후의 데이터는 처리하지 않아도 되기 때문에 성능상 효율적이다.

### find, some, every 함수

## (5) 무한-중단(range-take) 패턴

## (6) 분할-평탄 패턴

## (7) 변형-평탄 패턴

## (8) 결합-누적(zip-reduce) 패턴

## (9) 해시-매치(hash-match) 패턴

## (10) 리스트 프로세싱 함수 유형별 개념 정리
