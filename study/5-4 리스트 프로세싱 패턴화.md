# 리스트 프로세싱 패턴화

리스트 프로세싱의 다양한 조합을 좀더 구조적으로 이해할 수 있도록 패턴화된 몇 가지 사례를 소개합니다.

## (1) 변형-누적(map-reduce) 패턴

변형-누적(map-reduce) 패턴은 가장 널리 사용되는 패턴으로, 초기 이터러블을 map으로 변경한 뒤 reduce로 누적하여 최종 결과를 도출하는 방식이다.

- 프로그램의 결과물이 단일 값일 때 주로 사용 (배열이 아닌 객체, 숫자, 문자열 등으로 데이터를 변환하는 데 적합)
- 데이터 집계나 변환, 누적 작업애 매우 유용

### 상품의 총 수량

상품 목록에서 각 상품의 수량을 추출(변경)한 뒤 이를 누적하여 전체 수량을 계산한다.

```tsx
const totalQuantify = products =>
  products.map(product => product.quantity).reduce((a, b) => a + b, 0);
```

### Query String을 객체로 변환하기

Query String은 &로 구분된 키-값 쌍의 문자열 데이터로 이를 객체로 변환하면 각 키와 값이 속성으로 매핑된다.

```tsx
const queryString = 'name=Marty%20Yoo&age=41&city=Seoul';

const queryObject = queryString
  .split('&')
  .map(param => param.split('='))
  .map(entry => entry.map(decodeURIComponent))
  .map(([key, val]) => ({ [key]: val }))
  .reduce((a, b) => Object.assign(a, b), {});

console.log(queryObject);
// {name: "Marty Yoo", age: "41", city: "Seoul"}
```

### 객체를 Query String으로 변환하기

변형-누적 패턴을 사용하여 객체의 키-값 쌍을 Query String으로 변환한다. 이 패턴에서 map은 데이터를 변형하며 reduce는 각 요소를 순회하여 최종 결과를 누적한다. 객체의 키-값 쌍은 Query String 형태로 직렬화된다.

```tsx
const params = { name: 'Marty Yoo', age: '41', city: 'Seoul' };
```

```tsx
const queryString = Object.entries(params)
  .map(entry => entry.map(encodeURIComponent))
  .map(([key, value]) => `${key}=${value}`)
  .reduce((a, b) => `${a}&${b}`);

console.log(queryString);
// "name=Marty%20Yoo&age=41&city=Seoul"
```

join은 배열을 문자열로 변환할 때 사용하며 배열의 값들을 더하면서 그 사이에 separator를 삽입하다. 본질적으로 join은 reduce로 구현할 수 있는 동작을 추상화한 함수이다.

```tsx
const queryString2 = Object.entries(params)
  .map(entry => entry.map(encodeURIComponent))
  .map(entry => entry.join('='))
  .join('&');

console.log(queryString2);
// "name=Marty%20Yoo&age=41&city=Seoul"
```

커링과 파이프를 이용하여 동일한 코드를 더 간결하게 표현할 수 있다.

```tsx
const queryString3 = pipe(
  Object.entries(params),
  map(map(encodeURIComponent)),
  map(join('=')),
  join('&'),
);

console.log(queryString3);
// "name=Indong%20Yoo&age=41&city=Seoul"
```

## (2) 중첩-변형(nested-map) 패턴

리스트 프로세싱에서 중첩된 데이터 구조를 처리하거나 데이터의 계층을 따라 각 수준에서 변형을 수행할 때 사용하는 패턴이다.

- 트리 구조나 2차원 배열 등 계층적인 데이터를 변형하거나 처리할 때 매우 유용

### 트리 구조 변형

```tsx
const tree = [
  { id: 1, children: [{ id: 2 }, { id: 3 }] },
  { id: 4, children: [{ id: 5 }] },
];

const transformedTree = tree.map(({ id, children }) => ({
  name: `parent-${id}`,
  children: children.map(child => ({ name: `child-${child.id}` })),
}));

console.log(transformedTree);
// [
//   { name: "parent-1", children: [ { name: "child-2" }, { name: "child-3" } ] },
//   { name: "parent-4", children: [ { name: "child-5" } ] }
// ]
```

### 달력 그리기(2차원 배열 join)

다음은 2차원 배열을 처리하는 리스트 프로세싱의 다양한 패턴을 보여주는 예제이다.
특히 데이터를 생성하고 가공한 후 적절히 변환하여 직관적으로 출력하는 과정에 중점을 둔다.

```tsx
//
const getMonthEndDates = (monthEnd: Date) =>
  monthEnd.getDay() === 6
    ? []
    : range(monthEnd.getDate() - monthEnd.getDay(), monthEnd.getDate() + 1);

// 지난 달, 이번 달, 다음 달의 필요한 날짜 데이터를 생성하여 주 단위로 나눔
const generateCalendar = (prevMonthEnd: Date, currentMonthEnd: Date) =>
  pipe(
    flat([
      getMonthEndDates(prevMonthEnd), // range(29, 31) 9월 29 ~ 30일
      range(1, currentMonthEnd.getDate() + 1), // range(1, 32) 10월 1 ~ 31일
      range(1, 7 - currentMonthEnd.getDay()), // range(1, 3) 11월 1 ~ 2일
    ]),
    chunk(7),
    toArray,
  );

// 2차원 배열을 문자열로 변환
const formatCalendar = (calendarWeeks: number[][]) =>
  pipe(
    calendarWeeks,
    map(map(day => (day < 10 ? ` ${day}` : `${day}`))),
    map(join(' ')),
    join('\n'),
  );

const renderCalendar = (year: number, month: number) =>
  pipe(
    generateCalendar(
      new Date(year, month - 1, 0), // 지난달 마지막 날
      new Date(year, month, 0), // 이번 달 마지막 날
    ),
    formatCalendar,
    console.log,
  );

renderCalendar(2024, 10);
// 29 30  1  2  3  4  5
//  6  7  8  9 10 11 12
// 13 14 15 16 17 18 19
// 20 21 22 23 24 25 26
// 27 28 29 30 31  1  2
```

### 1) renderCalendar 함수 - 합성과 재사용성

generateCalendar와 formatCalendar를 합성하여 최종적으로 달력을 생성하고 출력합니다. formatCalendar만 다른 함수로 변경하면 HTML이나 CSV 등 다양한 출력 형태로 확장이 가능하다.

### 2) generateCalendar 함수

지난 달, 이번 달, 다음 달의 필요한 날짜 데이터를 생성하여 주 단위(2차원 배열)로 반환합니다.
flat()을 사용해 1차원 이터레이터로 평탄화한 후 chunk()를 사용해 데이터를 다시 7일 단위로 나누어 주 단위 배열을 생성한다.

### 3) formatCalendar 함수

생성된 주 단위의 배열을 가독성 높은 문자열로 변환하여 출력한다.

---

사용된 핵심 패턴을 정리하면 다음과 같다.

- 평탄화 후 재분할 : chunk(7, flat([range(), range(), range()]))는 날짜 범위들을 평탄화한 후 7일 단위로 재분할하여 주 단위 데이터를 생성한다.
- 2차원 데이터 중첩 변형 : map(map(...))에서는 중접된 데이터를 처리하며 변경한다.
- 레벨 간 데이터 누적 : map(join(''))으로 내부 배열(주 단위 데이터)을 공객으로 연결된 문자열로 변환한다.

## (3) 반복자-효과(Iterator-forEach) 패턴

반복자-효과(Iterator-forEach) 패턴은 리스트 프로세싱에서 이터레이터를 만들어둔 후 지연 평가를 통해 데이터를 소비하며 부수적인 효과(forEach)를 발생시키는 패턴이다.

- 주로 데이터를 변형하거나 가져온 후 하나씩 소비하면서 특정 작업(예: 로깅, 출력, 네트워크 요청 등)을 수행할 때 사용된다.
- 패턴의 결과로 최종 결과로 최종 데이터는 생성되지 않으며 작업 자체가 목적이 되는 경우에 적합하다.

### 콘솔 출력으로 로그 남기기

반복자-효과 패턴을 사용하여 숫자 배열을 2배로 변환한 후 각 값을 콘솔에 출력

```javascript
fx(range(5))
  .map(x => x * 2)
  .forEach(x => console.log('Processed: ${x}'));
```

### 결제 동기화 스케줄러 코드

5.3절에서 사용했던 비동기 반복을 제어하는 코드도 반복자-효과 패턴이다.

```javascript
async function main() {
  await fx(range(Infinity))
    .toAsync()
    .forEach(() => Promise.all([
      syncPayments(),
      delay(10000)
    ]))；
}
```

### 부수 효과를 격리하는 forEach

forEach는 반환값이 없는 메서드로 명시적으로 부수 효과를 수반하는 동작을 수행하기 위해 설계되었다.
이는 주어진 콜백 함수를 배열의 각 요소에 대해 호출하지만 호출 결과를 반환하지 않는다.
대신 <u>코드의 의도를 명확히 전달하며 **데이터의 변형**과 **부수 효과**를 **분리**</u>하는 데 기여한다.

따라서 특정 코드 블록에서 어떤 변화가 일어나는지 예측가능해지며 문제 발생시 디버깅이 용이해진다.

예를 들어 데이터의 순수한 변환은 map, filter, reduce와 같은 메서드에서 처리되고 DOM 파일 삭제, 파일 저장, 로그 작성, API 호출 등의 부수 효과는 forEach 내에서 처리된다.

#### 부수 효과를 일으키면서 실행 결과를 반환하는 mapEffect 함수

mapEffect 함수명과 같은 이름을 사용하여 map과 유사하게 동작하지만 부수 효과를 포함한 동작임을 명확히 표현할 수 있다. 이렇게 하면 코드를 간결하게 유지하면서도 의도를 명확히 전달할 수 있다.

forEach나 mapEffect 같은 함수는 부수 효과를 의도적으로 허용하면서도 부수 효과가 필요한 구간을 명확히 구분하도록 돕는 유용한 도구이다. 이렇게 구분하면 순수 함수와 부수 효과의 격리를 실현하는 데 도움이 된다.

## (4) 필터-중단(filter-take) 패턴

필터-중단(filter-take) 패턴은 리스트 프로세싱에서 데이터를 조건에 따라 필터링한(filter) 후 일부 데이터만 선택하여(take) 소비하는 패턴이다.

- 대규모에서 특정 조건을 만족하는 일부 데이터만 빠르게 추출해야 할 때 유용하다.
- 데이터를 필요한 만큼만 처리하고 조건을 만족한 시점의 이후의 데이터는 처리하지 않아도 되기 때문에 성능상 효율적이다.

### find, some, every 함수

find, some, every 함수는 filter와 take를 활용해 명령형 방식 없이도 효율적으로 구현할 수 있다.

<!-- prettier-ignore -->
```typescript
const find = <A>(f: (a: A) => boolean, iterable: Iterable<A>) =>
    pipe(
      iterable,
      filter(f),
      take(1),
      ([found]) => found as A | undefined
    );

  const found1 = find(a => a > 3, [1, 2, 3, 4]);
  const found2 = find(a => a > 4, [1, 2, 3, 4]);
  console.log(found1); // 4
  console.log(found2); // undefined

  const some = <A>(f: (a: A) => boolean, iterable: Iterable<A>) =>
    pipe(
      iterable,
      filter(f),
      take(1),
      ([...arr]) => arr.length === 1,
    );

  console.log(some(a => a % 2 === 0, [1, 3, 5]));
  // false
  console.log(some(a => a % 2 === 1, [1, 3, 5]));
  // true

  const every = <A>(f: (a: A) => boolean, iterable: Iterable<A>) => pipe(
    iterable,
    reject(f),
    take(1),
    ([...arr]) => arr.length === 0,
  );

  console.log(every(a => a > 2, [1, 3, 5]));
  // false
  console.log(every(a => a > 0, [1, 3, 5]));
  // true
```

## (5) 무한-중단(range-take) 패턴

무한-중단 패턴은 끝이 없는 데이터 스트림에서 필요한 만큼만 데이터를 추출하기 위한 패턴이다. range를 사용해 무한히 증가하는 숫자나 특정 규칙을 따르는 데이터를 생성하고 take를 이용해 원하는 개수만큼 데이터를 추출한다.

- 데이터가 정해진 개수보다 더 많을 때 효율적이다.
- 명령형 스타일로 비유하자만 while-break 구조와 유사한 역할을 한다.

이 패턴은 데이터가 정해진 개수보다 더 많을 때 효율적이다.

5.2절의 콜라츠 추측 풀기도 무한-중단 패턴의 전형적인 예제이다.

5.3절에서 살펴봤던 남아 있는 데이터가 있을 때까지 요청을 반복하는 작업도 무한-중단 패턴의 한 예이다.

## (6) 분할-평탄 패턴

분할-평탄 패턴은 데이터를 일정 크기로 분할한 뒤 다시 평탄화(flat)하여 원하는 형태로 변환하는 리스트 프로세싱 기법이다. 이 패턴은 데이터의 구성을 조정하거나 대규모 데이터를 일정한 단위로 처리한 뒤 결과를 합칠 때 유용하다.

- 요청 크기 제한이 있는 API 호출할 때 이 패턴을 적용할 수 있다.
- 페이지 단위로 데이터를 처리할 때 이 패턴을 적용할 수 있다.

### API 요청 제한에 적용하기

chunk를 사용하여 요청을 5개씩 분할하고 각 그룹을 처리한 뒤 flat을 사용해 평탄ㄴ화하여 최종 결과를 하나의 배열로 반환한다. 이를 통해 대규모 데이터를 효율적으로 처리하고 제한 조건을 준수할 수 있다.

```typescript
const orders = await fx(payments)
  .map(p => p.store_order_id)
  .chunk(5) // 요청을 5개씩 분할
  .toAsync()
  .map(StoreDB.getOrders)
  .flatO // 평탄화
  .toArray();
```

## (7) 변형-평탄 패턴

변형-평탄 패턴은 데이터를 변형한(map) 뒤 결과를 평탄화하여(flat) 하나의 연속된 데이터 흐름으로 만드는 리스트 프로세싱 기법이다.

- 이 패턴은 중첩된 데이터를 단일 수준으로 펼치거나 각 요소를 변형하여 새 데이터를 생성하고 이를 하나의 구조로 병합할 때 유용하다.

### 댓글과 답글 하나로 병합하기

```javascript
const comments = [
  {
    id: 1,
    text: 'First comment',
    replies: [{ id: 11, text: 'Reply 1-1' }],
  },
  {
    id: 2,
    text: 'Second comment',
    replies: [],
  },
  {
    id: 3,
    text: 'Third comment',
    replies: [
      { id: 31, text: 'Reply 3-1' },
      { id: 32, text: 'Reply 3-2' },
    ],
  },
];

fx(comments)
  .map(({ id, text, replies }) => [{ id, text }, ...replies])
  .flat()
  .forEach(console.log);

// [
//   { id: 1, text: "First comment" },
//   { id: 11, text: "Reply 1-1" },
//   { id: 2, text: "Second comment" },
//   { id: 3, text: "Third comment" },
//   { id: 31, text: "Reply 3-1" },
//   { id: 32, text: "Reply 3-2" }
// ]
```

### 중첩된 데이터 구조에서 평탄화하여 합산하기

map(f).flat()은 자주 사용되는 패턴으로 이를 간결하게 처리하기 위해 flatMap과 같은 함수를 제공하기도 한다.

## (8) 결합-누적(zip-reduce) 패턴

결합-누적 패턴은 두 배열(keys와 values)을 결합하고 각 쌍을 객체의 키와 값으로 변환하여 하나의 객체로 누적한다.

### keys와 values로 객체 만들기

```javascript
const keys = ['name', 'job', 'location'];
const values = ['Marty', 'Programmer', 'New York'];

const object = fx(zip(keys, values))
  .map(([key, val]) => ({ [key]: val }))
  .reduce((a, b) => Object.assign(a, b), {});

console.log(object);
// { name: 'Marty', job: 'Programmer', location: 'New York' }

// prettier-ignore
const obj = pipe(
    fx(zip(keys, values)),
    Object.fromEntries
  );

console.log(obj);
// { name: 'Marty', job: 'Programmer', location: 'New York' }
```

### 리스트에 고유 ID 부여하기

range(Infinity)와 zip을 사용해 리스트의 각 요소에 고유 ID를 부여하는 예제이다.

toArray는 이터러블을 순회하며 배열로 변환하는 함수로 본질적으로 reduce와 유사한 동작을 수행한다.

```typescript
const items = ['Apple', 'Banana', 'Cherry'];

const itemsWithIds = pipe(
  zip(range(Infinity), items),
  map(([id, item]) => ({ id, item })),
  toArray,
);

console.log(itemsWithIds);

// [
//   { id: 0, item: "Apple" },
//   { id: 1, item: "Banana" },
//   { id: 2, item: "Cherry" },
// ]
```

## (9) 해시-매치(hash-match) 패턴

해시-매치 패턴은 리스트 프로세싱에서 데이터를 효율적으로 구성하거나 조회하기 위해 해시 구조(키-값 맵)을 생성하는 데 사용된다. 데이터를 키로 매핑하거나 그룹화, 카운팅, 변환 등의 작업에 활용하며 indexBy, groupBy와 같은 작업이 이에 해당한다. 참고로 indexBy와 groupBy 역시 본질적으로 reduce를 활용해 구현한다.

- 이 패턴은 특정 데이터에 빠르게 접근하거나 데이터를 재구성해야 할 때 특히 유용하다.

해시 기반 구조를 생성하면 O(n) 복잡도로 특정 작업을 처리할 수 있어 성능적인 이점도 제공한다.

### posts와 users를 매칭하기

posts와 users를 매칭하여 각 게시물에 작성자 정보를 추가한다.

users 데이터를 indexBy를 사용해서 해시 구조로 변환후 posts와 효율적으로 매칭한다.

```typescript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
];

const posts = [
  { id: 1, title: 'FP', user_id: 1 },
  { id: 2, title: 'OOP', user_id: 2 },
  { id: 3, title: 'MPP', user_id: 2 },
];

const usersById = indexBy(user => user.id, users);
// {
//     "1": {
//         "id": 1,
//         "name": "Alice"
//     },
//     "2": {
//         "id": 2,
//         "name": "Bob"
//     }
// }

const postsWithUsers = posts.map(post => ({
  ...post,
  user: usersById[post.user_id],
}));

console.log(postsWithUsers);
// [
//   { id: 1, title: "FP", user_id: 1, user: { id: 1, name: "Alice" } },
//   { id: 2, title: "OOP", user_id: 2, user: { id: 2, name: "Bob" } },
//   { id: 3, title: "MPP", user_id: 2, user: { id: 2, name: "Bob" } },
// ]
```

```tsx
declare function indexBy<A extends Key>(
  f: (a: A) => A,
  iterable: Iterable<A>,
): {
  [K in A]: K;
};
```

indexBy 함수는 특정 키를 기준으로 이터러블 데이터를 해시 구조로 변환하는데 사용된다.
주어진 이터러블의 각 요소에 보조 함수를 적용하여 키 값을 추출하고 해당 키를 객체의 속성으로 설정한다.
이 과정에서 보조 함수는 반드시 고유한 키 값을 반환하도록 구성해야 한다.

### posts와 comments를 매칭하기

posts와 comments를 매칭하여 각 게시물에 연결된 댓글을 추가한다.

groupBy를 사용해 comments를 post_id로 그룹화한 후 posts와 효율적으로 매칭한다.

```typescript
const posts = [
  { id: 1, title: 'FP', user_id: 1 },
  { id: 2, title: 'OOP', user_id: 2 },
  { id: 3, title: 'MPP', user_id: 2 },
];

const comments = [
  { id: 1, text: 'Great post!', post_id: 1 },
  { id: 2, text: 'Very informative.', post_id: 1 },
  { id: 3, text: 'Thanks for sharing!', post_id: 2 },
];

const commentsByPostId = groupBy(comment => comment.post_id, comments);
// {
//     "1": [
//         {
//             "id": 1,
//             "text": "Great post!",
//             "post_id": 1
//         },
//         {
//             "id": 2,
//             "text": "Very informative.",
//             "post_id": 1
//         }
//     ],
//     "2": [
//         {
//             "id": 3,
//             "text": "Thanks for sharing!",
//             "post_id": 2
//         }
//     ]
// }

const postsWithComments = posts.map(post => ({
  ...post,
  comments: commentsByPostId[post.id] || [],
}));

console.log(postsWithComments);
// [
//   {
//     id: 1, title: "FP", user_id: 1, comments: [
//      { id: 1, text: "Great post!", post_id: 1 },
//      { id: 2, text: "Very informative.", post_id: 1 }
//     ]
//   },
//   {
//     id: 2, title: "OOP", user_id: 2, comments: [
//       { id: 3, text: "Thanks for sharing!", post_id: 2 }
//     ]
//   },
//   { id: 3, title: "MPP", user_id: 2, comments: [] },
// ]
```

## (10) 리스트 프로세싱 함수 유형별 개념 정리

리스트 프로세싱 파이프라인을 설계할 때 ‘어떤 시점에 변환이 이뤄지는지’, ‘어디서 데이터를 실제로 소비하는지’ 그리고 '최종 결과를 어떻게 산출하는지’ 등을 체계적으로 파악하여 더 효율적이고 가독성 높은 코드를 작성할 수 있다.

### 지연 중간 연산

- 결과가 실제로 필요할 때까지 연산을 미루며 이 단계만으로는 최종 결과가 나오지 않는다.
- 예시 함수 : map, filter, zip 등

### 단축(short-circuit) 중간 연산

- 특정 조건이 충족되면 그 시점에서 더 이상 데이터를 읽지 않아 불필요한 연산을 건너뛴다.
- 예시 함수 : take, takeWhile, takeUntilInclusive 등

### 터미널 연산(terminal operation)

- 실제 이터러블을 전부(또는 조건부로) 소비하여 최종 결과(누적값/특정 요소)를 만들어낸다. 한번 연산을 호출하면 지연이 해제되고 실제 순회가 일어난다.
- 예시 함수 : find, every, some, reduce 등

### 폴드/리듀스(fold/reduce) 연산

- 터미널 연산 중에서도 시퀀스 전체를 하나의 값으로 누적하여 반환하는 연산을 가리킨다.
- 예시 함수 : reduce, groupBy, indexBy 등. Promise.all이나 Array.fromAsync 같은 함수도 포함

### 부수 효과(side effect)

- 출력/로그/파일 쓰기 등 외부 상태를 변화시키는 연산이다. 보통 내부 콜백에서 '무언가를 실행'하고 끝내는 형태를 띤다.
- 예시 함수 : forEach 등
