## 2.3 Multiparadigm Languages and Metaprogramming – From LISP

We just examined how to assign types to higher-order functions frequently used in functional programming, thereby implementing functions that are both highly polymorphic and type-safe. In this chapter, we will explore how to combine these higher-order functions with classes and apply the iterable pattern to form a structure that allows for more readable processing of data streams. This pattern is already widely used in many modern languages’ standard libraries and greatly assists developers in expressing data flows clearly and intuitively.

The examples in this chapter demonstrate how to combine various language features—generics, first-class functions, classes, and iterable protocols—to build flexible and highly extensible abstractions. By doing so, you can achieve the kind of code expressiveness associated with metaprogramming, implement runtime modifications of functionality, and gain an experience that feels as though you’ve extended the language itself.

Here, metaprogramming refers to a programming technique where programs treat themselves or other programs as data, enabling them to analyze, modify, generate, or execute code. This approach of dynamically manipulating code as data reaches its zenith in traditional LISP-family languages, where developers can directly redefine code structures and evaluation processes, while freely manipulating language syntax through macros.

While TypeScript and other modern multi-paradigm languages don't offer the same direct metaprogramming capabilities as LISP-family languages, we can strategically combine the language features we've explored to achieve similar metaprogramming benefits in practice. In this chapter, we'll examine how multi-paradigm languages can accomplish the rich abstraction and dynamic transformation that were once thought exclusive to LISP-family languages, along with the strategies that make this possible.

### Pipe Operator

Before that, let’s take a moment to travel to the future—or perhaps the past. As shown in the following example from [Code 2-23], code that needs to be read from bottom-right to top-left can be unfamiliar and therefore less readable. Since LISP excels in lazy evaluation and metaprogramming, developers can create their own `pipe` function to address this issue. Furthermore, some languages already provide built-in pipe operators to effectively improve readability. The second example demonstrates the use of a pipe operator.

##### [Code 2-24] Pipe Operator

```javascript
// From [Code 2-23]...
forEach(printNumber,
  map(n => n * 10,
    filter(n => n % 2 === 1,
      naturals(5))));
// 10
// 30
// 50

// Pipe Operator
naturals(5)
  |> filter(n => n % 2 === 1, %)
  |> map(n => n * 10, %)
  |> forEach(printNumber, %)
// 10
// 30
// 50
```

We chose to design our higher-order functions with the parameter order map(f, iterable) rather than map(iterable, f), following the conventions of traditional functional programming languages. This order improves readability in three key cases: when nesting functions, using the pipe operator, and supporting currying. Had we adopted the reverse order `map(iterable, f)`, the code would need to be written as follows:

##### [Code 2-25] What if the parameter order was reversed?

```javascript
forEach(map(filter(naturals(5), n => n % 2 === 1), n => n * 10), printNumber);

naturals(5)
  |> filter(%, n => n % 2 === 1)
  |> map(%, n => n * 10)
  |> forEach(%, printNumber)
```

Clearly, the code in [Code 2-24] is more readable. The pipeline code is not bad, but having `%` in the first argument of those higher-order functions is a bit visually distracting.

### Combining Classes, Higher-Order Functions, Iterators, and the Type System

We briefly looked at the possibility of a Pipe Operator being introduced into JavaScript, but there’s no need to wait around for it. We can solve this readability issue right now by appropriately combining classes from object-oriented paradigm, iterables, functional functions, and the type system.

#### Extending Iterable with a Generic Class

First, we created a generic class as shown in [Code 2-26] to extends `Iterable`. we defined a generic class `FxIterable<A>`, and it has `iterable: Iterable<A>` internally.

##### [Code 2-26] FxIterable\<A>

```typescript
class FxIterable<A> {
  private iterable: Iterable<A>;

  constructor(iterable: Iterable<A>) {
    this.iterable = iterable;
  }
}
```

In [Code 2-27], we specify an access modifier (`private`) directly in the constructor parameter, such as `private iterable: Iterable<A>`. By doing this, you can omit the code that explicitly defines the field and assigns it a value; the `iterable` field will be automatically created within the class. This approach helps make your class definitions more concise.

##### [Code 2-27] FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}
}
```

The type parameter `A` of `FxIterable<A>` is determined at the time you instantiate the class, based on the type of the `iterable` argument. This works similarly to how type parameters of a generic function are determined by the function arguments at call time.

Now we can add various higher-order functions as methods to this generic class.

#### Adding a map Method to FxIterable\<A>

Next, let’s add a `map` method to the `FxIterable` class, and implement the method using the previously written `map` function.

##### [Code 2-28] Adding a map Method to FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return new FxIterable(map(a => f(a), this.iterable));
  }
}

const mapped = new FxIterable(['a', 'b']) 
  .map(a => a.toUpperCase())             
  .map(b => b + b);                     

// [const mapped: FxIterable<string>]
// [a: string]
// [b: string]
```

The `map` method creates a new iterable iterator by applying `map(f)` to `this.iterable`, then returns `FxIterable<B>`. A `FxIterable` instance can call `map` repeatedly in a chain-like style. We can now read the code from top to bottom. The implementation leverages generics effectively, resulting in proper type inference - `mapped` becomes an instance of `FxIterable<string>`, and the type system correctly identifies `a` as a `string`.

#### Expressing fx(iterable: Iterable\<A>): FxIterable\<A> More Concisely

We can make the part `new FxIterable(['a', 'b'])` a bit more concise. Let’s add a helper function `fx` that easily creates a `FxIterable` instance.

##### [Code 2-29] Adding a fx Helper Function

```typescript
function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const mapped2 = fx(['a', 'b'])
  .map(a => a.toUpperCase())
  .map(b => b + b);

// [const mapped2: FxIterable<string>]
```

This allows for even more concise code with improved readability.

#### Creating filter and forEach Methods

Let’s now add `filter` and `forEach` methods.

##### [Code 2-30] Adding filter and forEach to FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return new FxIterable(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return new FxIterable(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }
}
```

You can use the `fx` function defined in [Code 2-29] to make the internal code of `FxIterable` more concise.

##### [Code 2-30a] Replacing new FxIterable(...) with fx(...)

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }
}
```

Now we can iterate with `forEach` to produce output effects.

##### [Code 2-31] map, forEach

```typescript
fx(['a', 'b'])
  .map(a => a.toUpperCase())
  .map(a => a + a)
  .forEach(a => console.log(a));
// AA
// BB
```

Let’s rewrite [Code 2-24] using `fx`.

##### [Code 2-32] naturals, filter, map, forEach

```javascript
// Nested functions
forEach(printNumber,
  map(n => n * 10,
    filter(n => n % 2 === 1,
      naturals(5))));

// Pipe operator
naturals(5)
  |> filter(n => n % 2 === 1, %)
  |> map(n => n * 10, %)
  |> forEach(printNumber, %)

// Chaining
fx(naturals(5))
  .filter(n => n % 2 === 1)
  .map(n => n * 10)
  .forEach(printNumber);
// 10
// 30
// 50
```

We have now reached quite a complete form. From these examples, while the nested function and pipe operator approaches are sufficiently readable, the chaining approach is very similar to how modern languages operate and is especially familiar and readable. Chaining approach allows developers to intuitively express data transformations through sequential method calls, making each step clear and the code flow easier to follow. This style is especially reminiscent of JavaScript’s array method chaining or Java’s Stream API, which many developers already find familiar. As mentioned, this style is adopted by many multiparadigm languages.

Also, with chaining, the IDE can offer hints about which methods are available next, making the development process more convenient.

#### Creating a reduce Method

Now we’ll add a `reduce` method.

##### [Code 2-33] Adding a reduce Method to FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {
  }

  // ... omitted methods ...

  reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc {
    return reduce(f, acc, this.iterable);
  }
}
```

It’s straightforward to add. However, as with the function we implemented previously, you need to support two different usage patterns by overloading the method. In TypeScript, overloading a method is done just like function overloading: It's technique where multiple function or method signatures are defined, while providing only a single implementation.

##### [Code 2-34] Overloading the reduce Method

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ... omitted methods ...

  reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc; // (1)
  reduce<Acc>(f: (a: A, b: A) => Acc): Acc; // (2)
  reduce<Acc>(f: (a: Acc | A, b: A) => Acc, acc?: Acc): Acc {
    return acc === undefined
      ? reduce(f, this.iterable) // (3)
      : reduce(f, acc, this.iterable); // (4)
  }
}
```

Here’s what’s going on in the signatures (1, 2) and the implementation (3, 4):

1. `reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc;`
   - This signature is used when `reduce` is called with an initial value `acc`.
   - The generic type `Acc` is used to define the type of the accumulator.
   - The function `f` takes the accumulator `acc` and each element `a` of the iterable, returning a new accumulator.
   - `A` is the type of the elements in `private Iterable<A>`.

2. `reduce<Acc>(f: (a: A, b: A) => Acc): Acc;`
   - This signature is for when `reduce` is called without an initial value.
   - In that case, the first element of the iterable is used as the initial value.
   - `A` is the type of the elements in `private Iterable<A>`.
   - The generic type `Acc` defines the type of the accumulator.

3. When `acc` is `undefined`
   - `reduce(f, this.iterable)` is called.
   - In that scenario, the first element of the iterable is used as the initial accumulator value inside the `reduce` function.

4. When `acc` is not `undefined`
   - `reduce(f, acc, this.iterable)` is called.
   - The specified `acc` is used as the initial accumulator.

With the `reduce` method, you can now flexibly use both the form with an initial value and the form without one.

##### [Code 2-35] Using the reduce Method

```typescript
// When there is no initial value
const num = fx(naturals(5)) // FxIterable<number> (1, 2, 3, 4, 5)
    .filter(n => n % 2 === 1) // FxIterable<number> (1, 3, 5)
    .map(n => n * 10) // FxIterable<number> (10, 30, 50)
    .reduce((a, b) => a + b); // [a: number] [b: number]

console.log(num); // [num: number]
// 90

// When there is an initial value
const num2 = fx(naturals(5)) // FxIterable<number> (1, 2, 3, 4, 5)
    .filter(n => n % 2 === 1) // FxIterable<number> (1, 3, 5)
    .map(n => n * 10) // FxIterable<number> (10, 30, 50)
    .reduce((a, b) => a + b, 10); // [a: number] [b: number]

console.log(num2); // [num2: number]
// 100
```

With `map`, `filter`, `reduce`, and `forEach` methods implemented, we can now write code that is more readable, safe, and easier to maintain through chaining.

### Learning from LISP (Clojure) – Code is Data, Data is Code

Let’s talk about LISP for a moment. LISP holds a very important place in the history of programming languages, thanks to its unique syntax and philosophy. This language has the characteristic that “code is data, and data is code,” allowing the syntax of a programming language to be represented and manipulated as a data structure. Consequently, programs can dynamically generate new code and execute it, making advanced techniques such as metaprogramming easy to implement. This greatly enhances the flexibility and extensibility of code.

In this section, using the LISP-family language Clojure as an example, we will explain the basic concepts, macros, and metaprogramming of LISP, and then apply these ideas to TypeScript to broaden our perspective on multiparadigm languages.

#### Clojure

Clojure is a functional programming language in the LISP family, developed by Rich Hickey in 2007. It runs on the JVM, combining the features of a modern LISP language with access to Java’s extensive library ecosystem. Clojure emphasizes immutability and first-class functions, and offers powerful features for concurrent programming. It also treats code and data as identical, enabling metaprogramming and increasing code flexibility and extensibility.

#### Getting Started with Clojure – S-expressions

In LISP, an S-expression (Symbolic Expression) refers to list-based syntax representation. This approach enables handling both code and data with the same (list-based) structure, which means the code itself can be handled as data. For instance, `(+ 1 2)` in LISP is simultaneously code that adds 1 and 2, and also a list-structured piece of data.

##### [Code 2-36] Code to Be Executed as a List

```clojure
(+ 1 2)
```

[Code 2-36] is an expression that adds two numbers, but it can also be interpreted as a list structure, as follows:

- First element: the operator (function) `+`
- Remaining elements: operands `1` and `2`

In LISP-family languages, calling a function takes the form of a list, where the first element is the function, and the rest are the arguments to that function.

To illustrate, let’s represent this concept in TypeScript in a simplified manner.

##### [Code 2-37] A List Is a Value

```typescript
[add, 1, 2]
```
The array contains as `add` function for summing two numbers, along with the operand elements `1` and `2`. This construct, `[add, 1, 2]`, exists fundamentally as an array data structure. Given the presence of an evaluation function, this data structure could be transformed into executable code and subsequently evaluated to produce a computational result.

##### [Code 2-37a] Evaluating a List

```typescript
type Evaluatable<A, B> = [(...args: A[]) => B, ...A[]];

function evaluation<A, B>(expr: Evaluatable<A, B>) {
  const [fn, ...args] = expr;
  return fn(...args);
}

const add = (a: number, b: number) => a + b;
const result: number = evaluation([add, 1, 2]);
console.log(result); // 3
```

[Code 2-37a] demonstrates part of LISP's "code as data" concept using TypeScript by representing function calls as list-structured data and then evaluating them.

1. `Evaluatable<A, B>` Type Definition
   - This type defines a structure where the first element is a function type `((...args: A[]) => B)`, followed by values that serve as the function's arguments.
   - For example, `[add, 1, 2]` clearly expresses an array containing the `add` function and its arguments `1` and `2` as a typed structure.

2. `evaluation` Function
   - The `evaluation` function takes a value of type `Evaluatable<A, B>`. Using destructuring assignment, it extracts the first element as the function (`fn`) and the remaining elements as an array of arguments (`args`).
   - It then calls `fn(...args)` and returns the result, effectively "evaluating" the list-structured "code" represented as data.

3. Usage Example
   - The `add` function simply adds two numbers together.
   - The array `[add, 1, 2]` is a data structure that means "call the `add` function with arguments `1` and `2`.
   - When we evaluate this with `evaluation([add, 1, 2])`, it internally executes `add(1, 2)` and returns the result `3`.

This example allows us to execute code represented as data (in array form) through the `evaluation` function.

It's worth noting that this TypeScript example only works with code as data at runtime. In contrast, LISP can manipulate code as data during compilation as well, giving it more powerful capabilities to transform the code itself before it's executed at runtime. We'll explore this in more detail later.

### When map Executes in Clojure

The next code snippet is an example that returns the result of adding 10 to each element of a list:

##### [Code 2-38] map

```clojure
(map #(+ % 10) [1 2 3 4])
```

Here’s how this code works:

- First element: the function `map`
- Second element: an anonymous function `#(+ % 10)` (which adds 10 to the current element)
- Third element: the vector `[1 2 3 4]` (in Clojure, `[]` represents a vector, while `()` represents a list)

The `map` function returns the result of applying the given function `#(+ % 10)` to each element of the vector. When evaluated, the result becomes a lazy sequence in list form: `(11 12 13 14)`. Since this sequence is lazy, the actual evaluation only completes when the values are needed somewhere.

The expression `#(+ % 10)` is expanded by a reader macro into the anonymous function `(fn [x] (+ x 10))`. In Clojure, function definitions are also expressed as lists, which means this function definition itself can be treated as "both code and a data structure". A reader macro is a feature in languages like Clojure that substitutes certain symbols or patterns with predefined forms of code during the source code reading (Reader) stage.

#### Pulling Out the First Two Values

The next example shows using `let` and destructuring to retrieve the first two values from the result of `map` and print them.

##### [Code 2-39] let and Destructuring

```clojure
(let [[first second] (map #(+ % 10) [1 2 3 4])]
  (println first second))
;; 11 12
```

- The expression `(map #(+ % 10) [1 2 3 4])` generates a lazy sequence in the form of `(11 12 13 14)`.
- Within the `let` binding, `[first second]` performs destructuring to extract only the first two elements(`11` and `12`), evaluating just what's needed.
- Since `map` is lazy by design, elements are computed only when they're actually required.
- The `println` function outputs the values of `first` and `second`.
- The result displayed is  `11 12`.
- Note that `;;` denotes comments in Clojure syntax.

In LISP-family languages, code is represented as lists, and those lists remain just data until evaluated. When evaluation begins, these lists turn into actual function calls or logic. For instance, the anonymous function `(fn [x] (+ x 10))` generated by `#(+ % 10)` is both unevaluated “syntax(code)” and a "value" structured as a list.

Then this value combines with another list structure like `(map f list)`, Clojure delays evaluation until necessary. Only when evaluation becomes required does Clojure complete and execute the nested combinations of lists as actual logic. This ability to handle code and data in identical forms, along with gradual evaluation when needed, represents one of the fundamental strengths and distinguishing characteristics of LISP-family languages.

### Making User-Created Code and Classes into Lists in a Multiparadigm Language

I'd like to extend our `FxIterable` class to match the capabilities of [Code 2-39] in Clojure, achieving the same time complexity (with lazy evaluation support) and expressive power. What changes would we need to make to `FxIterable` to enable this? One key question is: How can we implement destructuring similar to Clojure's `let` with `[first second]` pattern? Perhaps we should create a method that converts `FxIterable` to an `Array`? Let's explore this idea by writing some code:

##### [Code 2-40] toArray

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ... omitted methods ...

  toArray(): A[] {
    return [...this.iterable];
  }
}

const [first, second] = fx([1, 2, 3, 4]).map(a => a + 10).toArray();
console.log(first, second); // 11 12
```

Here’s how this code works:

- The added `toArray()` method converts the internal iterable into an array. It uses the spread operator in the statement `return [...this.iterable];` to transform the iterable object into a proper array.
- The `fx` function creates an `FxIterable` instance. We call `map()` method to add 10 to each element, and then return an array transformed by `toArray()`.
- We use destructuring assignment to bind the first and second values from this array to the variables `first` and `second`.
- The result prints `11` and `12`.

We get the desired result, but we notice some drawbacks compared to [Code 2-39]. 
Specifically, we needed to append `.toArray()` after `map(...)`, and by calling `.toArray()`, we evaluate all four elements to build a complete array. How can we fix this? The good news is that we already have the answer! We can transform `FxIterable` into something more like the lists in LISP by making one fundamental change: turning `FxIterable` itself into a value that follows the iteration protocol we've been working with throughout our examples.

##### [Code 2-41] LISP-Like Lists as Iterables

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}
  
  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }
  
  // ... omitted methods ...
}

const [first, second] = fx([1, 2, 3, 4]).map(a => a + 10);
console.log(first, second); // 11 12
```

The solution is surprisingly simple: we just need to make `FxIterable` propter iterable.
By implementing `[Symbol.iterator]()` to return an iterator from `this.iterable`, we no longer need `toArray()` to destructure `[first, second]`. Only two elements need to be evaluated (i.e., the operation of adding 10 occurs just twice).

### LISP’s Extensibility – Macros and Metaprogramming

Returning to LISP: Let's consider a list that hasn't been evaluated yet and is intended to add 10 to its elements. With LISP, you can dynamically add any number of new features to this list before evaluation - such as filtering out odd numbers or excluding specific elements. For example, if a developer creates a function that removes elements based on certain logic and places it as the first element of the list, that list then behaves like code composed of entirely new operators and functions. Through this process, developers can extend the language's capabilities themselves and naturally integrate with existing language features like `let`.

Here is an example of defining a `reject` function, adding an operation to Clojure that wasn't available in the original language:

##### [Code 2-42] Applying a reject Function

```clojure
(defn reject [pred coll]
  (filter (complement pred) coll))

(let [[first second] (reject odd? (map #(+ % 10) [1 2 3 4 5 6]))]
  (println first second))
;; 12 14
```

Here’s how [Code 2-42] works:

- `reject` uses `filter` and `complement` to keep only elements that do not satisfy `pred`.
- `(map #(+ % 10) [1 2 3 4 5 6])` adds 10 to each, creating `(11 12 13 14 15 16)`.
- `reject odd?` removes `odd?` elements from the map result, leaving `(12 14 16)`.
- In the `let` form, `[first second]` destructures the first two elements `(12 14)` and binds them to `first` and `second`.
- The printed result of `first` and `second` with `printIn` is `12 14`.
- The `;;` is a comment syntax in Clojure.

This example demonstrates how developers can define their desired logic directly as functions, seamlessly integrate them with language features, and flexibly extend the language thanks to LISP's characteristic of delaying code evaluation.

#### Macros

In LISP-family languages, macros are not mere text replacements but **actual functions that accept code (in list form) as input and return code (in list form) as output**. Macros operate **at compile time**, transforming code while it’s still in an “unexecuted syntax” state, allowing you to rearrange the final code that will eventually run. This is how developers can flexibly alter or extend the language itself, even creating new syntax if desired.

A famous example is the `unless` macro:

##### [Code 2-43] unless

```clojure
(defmacro unless [test body]
  `(if (not ~test) ~body nil))
```

Looking at the definition of `unless` above, `test` and `body` are "code form parameters" passed to the macro. Unlike functions, which receive evaluated arguments, macros receive the original code forms-lists that have not yet been executed. This means the `unless` macro receives `test` and `body` similar to function arguments, but treats them as code structures (lists) themselves rather than executing their values.

For example:

##### [Code 2-44] Using unless

```clojure
(unless false
  (println "This line executes because the condition is false."))
```

Here, `false` is passed as the `test` argument to the `unless` macro from [Code 2-43], and `(println "This line executes because the condition is false.")` is passed as the `body` argument. At this point, these arguments are passed to the macro in their unevaluated form as code fragments (lists). Then, the `unless` macro uses these code fragments to generate new code at compile time, like this:

##### [Code 2-45] The Actual Code Produced by unless

```clojure
(if (not false)
  (println "This line executes because the condition is false.")
  nil)
```

Ultimately, the `unless` macro is a code transformer that takes `test` and `body` code as input and returns new code fragments that will eventually be executed. Since the compiler uses this returned code as the actual executable code, developers can freely create new syntax or features that weren't originally provided by the language.

Summarising, `test` and `body` are "code fragments" passed to the macro, and the `unless` macro reconstructs these fragments to generate new code at compile time. This gives developers an easy way to create their own language extension tools, which is one of the powerful metaprogramming capabilities of LISP-family languages.

#### ->> Macro

Let’s represent the code using `reject` as a pipeline. In Clojure, you can use the `->>` macro to make code look like a pipeline.

##### [Code 2-46] Pipeline Expression

```clojure
(let [[first second] (->> [1 2 3 4 5 6]
                          (map #(+ % 10))
                          (reject odd?))]
  (println first second))
;; 12 14
```

Here’s how it works:

- `->>` macro takes `[1 2 3 4 5 6]` as the first argument and passes it to the last argument of the following function.
- `map #(+ % 10)` adds 10 to each element of `[1 2 3 4 5 6]`, generating `(11 12 13 14 15 16)`.
- `reject odd?` removes the odd numbers from `(11 12 13 14 15 16)`, leaving `(12 14 16)`.
- `let` is used to bind the first two values of the list to `[first second]`.
- `println` prints `[first second]` values.
- The result is `12 14`.

This example illustrates how a pipeline macro can enhance code readability.

In Clojure, developers can directly define macros like `unless` or `->>`, and can also create expressions using special characters and symbols. This allows for easily adding new syntax such as `->>` to the language. When combined with S-expressions that use only parentheses without commas, this approach enables the creation of even more elegant and concise code. This powerful extensibility and flexibility comes from a key characteristic of LISP-family languages: the ability to represent program syntax as data structures that can be treated like delayed values.

#### Adding a reject Method to FxIterable

We will now add a `reject` method to the `FxIterable` class, producing the same behavior as the Clojure example that uses `reject`, and then express it in a chain.

##### [Code 2-47] Adding a reject Method to the FxIterable Class

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...

  reject(f: (a: A) => boolean): FxIterable<A> {
    return this.filter(a => !f(a));
  }
}

const isOdd = (a: number) => a % 2 === 1;
```

Usage example:

##### [Code 2-48] FxIterable Chaining and Destructuring

```typescript
const [first, second] = fx([1, 2, 3, 4, 5, 6])
  .map(a => a + 10)
  .reject(isOdd);

console.log(first, second); 
// 12 14
```

##### [Code 2-46 Revisited] Clojure Pipeline with Destructuring

```clojure
(let [[first second] (->> [1 2 3 4 5 6]
                          (map #(+ % 10))
                          (reject odd?))]
  (println first second))
;; 12 14
```

Both examples share the same programming paradigm and philosophy, thus achieving essentially the same meaning and value.

#### Extending the Language Through Collaborative Code, Objects, and Functions

We've explored how the imperative syntax of Destructuring Assignment, the object-oriented Method Chaining Pattern, and functional Higher-Order Functions cooperate closely through the iteration protocol, achieving high-level abstractions and flexibility that give the impression of extending the language itself.

##### [Code 2-48a] FxIterable Chaining and Destructuring

```typescript
const [first, second] = fx([1, 2, 3, 4, 5, 6])
  .map(a => a + 10)
  .reject(isOdd);
```

You can classify each part of above example code according to its role:

- Imperative syntax of destructuring assignment: `const [first, second] =`
- Object-oriented method chaining pattern: `fx().map().reject()`
- Functional higher-order functions and LISP: `map = (f: (a: A) => B, iterable: Iterable<A>) => Iterable<B>`

In addition to [Code 2-48a], this code involves many other concepts and functionalities—like generator from imperative code, object-oriented iterator, first-class functions, classes, generics, and type inference—interacting to deliver a lot of power and possibility.

Moreover, this code is not just a specialized implementation for a particular domain or problem; it shows a universal language-like approach. It doesn’t break from the existing language design or philosophy, so it integrates well with compile-time type processing and runtime error handling. It will also work seamlessly with new language features introduced in future releases.

In conclusion, this code is implemented in a multiparadigm way and simultaneously serves as a versatile code that can interact with all features supported by multiparadigm languages.

### Dynamically Extending Functionality at Runtime

#### Extending with to and Working in Harmony with OOP Objects

Earlier, we created a `toArray()` method for `FxIterable`. Then we made `FxIterable` itself iterable, which allows us to convert it to an `Array` using the spread operator. So why keep `toArray()`? Because it allows you to transform `FxIterable` into an array and continue chaining when it makes sense to do so. There will be situations where `toArray()` is more suitable.

##### [Code 2-49] Chaining with toArray()

```typescript
const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)  
  .map(n => n * 10)          
  .toArray()                      // Convert to Array<number>
  .sort((a, b) => a - b);         // Sort in ascending order

console.log(sorted); 
// [10, 30, 30, 50, 50]              

const sorted2 = [...fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1) 
  .map(n => n * 10)
]
  .sort((a, b) => a - b);

console.log(sorted2);
// [10, 30, 30, 50, 50]
```

`sorted` uses the `toArray()` method to convert the `FxIterable` object to an array, then uses the array's `sort` method to order the elements. By contrast, `sorted2` uses the spread operator to compare readability. The nested brackets and parentheses can reduce clarity because you have to follow the code flow from `map` up to the beginning of the spread operator, then back down to where the brackets close to find the `sort` method. Method-chaining, on the other hand, reads and operates sequentially, which improves readability.

Next, let's provide a `to` method that allows developers to dynamically extend `FxIterable` with methods like `toArray`, converting `FxIterable` to other types as needed.

##### [Code 2-50] A to Method That Enables Dynamic Converters

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator](): Iterator<A> {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...  

  to<R>(converter: (iterable: Iterable<A>) => R): R {
    return converter(this.iterable);
  }
}

const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)
  .to(iterable => [...iterable])  // Convert iterable to spread operator
  .sort((a, b) => a - b);         // [Array<number>.sort(compareFn?: ...): number[]]

console.log(sorted);              // const sorted: number[]
// [10, 30, 30, 50, 50]
```

We’ve converted it into an `Array`, type inference correctly infers `Array`, allowing you to safely continue method chaining. The `compareFn` parameter in `sort` is also inferred to take two `number`s.

Since `FxIterable` is itself an `Iterable`, we can simply implement it by passing `this` as shown below, and it will work exactly the same way:

##### [Code 2-51] Using this

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator](): Iterator<A> {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...  

  filter(f: (a: A) => boolean) {
    return fx(filter(f, this)); // <-- return fx(filter(f, this.iterable));
  }

  toArray() {
    return [...this]; // <-- return [...this.iterable];
  }

  to<R>(converter: (iterable: this) => R): R {
    return converter(this); // <-- return converter(this.iterable);
  }
}

const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)
  .to(iterable => [...iterable])  // Spread 'this' as it's an iterable
  .sort((a, b) => a - b);         // [a: number] [b: number]

console.log(sorted);              // const sorted: number[]
// [10, 30, 30, 50, 50]
```

Here, the parameter to `converter` is typed as `this`, and the argument is simply `this` (our iterable). This makes the code concise, and type inference works well, keeping your method chaining type-safe.

You can convert into other types, not just arrays, with the `to` method:

##### [Code 2-52] Converting to a Set

```typescript
const set = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                    // [50, 30, 10, 50, 30]
  .to(iterable => new Set(iterable));  // Convert to a Set, removing duplicates

console.log(set); 
// Set(3) {50, 30, 10}

const size = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                        
  .to(iterable => new Set(iterable))
  .add(10)                            // [Set<number>.add(value: number): Set<number>] 
  .add(20)                              
  .size;                              // set.size

console.log(size);                    // [size: number] 
// 4
```

We've converted to a `Set`, then used the `add` method and `size` property to output `4`. Type inference works nicely throughout this process, providing code hints and allowing us to safely continue chaining.

By using the `to` method, you can dynamically extend `FxIterable` at runtime to transform it into any type, all while maintaining excellent type inference. This allows you to work with not only buil

#### Using Set’s Set Operations

JavaScript’s `Set` now supports set-related methods, so object-oriented objects and iteration can be harmoniously used in a multiparadigm style:

##### [Code 2-53] Set.prototype.difference

```javascript
const set = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                        
  .to(iterable => new Set(iterable)) // Convert to a Set, removing duplicates: Set {50, 30, 10}
  .difference(new Set([10, 20]));    // Difference with [10, 20]: Set {50, 30}

console.log([...set]); 
// [50, 30]
```

This code filters out even numbers from the array, multiplies the remaining elements by 10, removes duplicates via a `Set`, then finds the difference with another `Set`, and finally converts the result back to an array. Note that at the time of writing, `difference()` method was only available in the latest browsers, so you might need to test this code in JavaScript to ensure compatibility.

#### Extending with chain

To further broaden the versatility of `FxIterable`, let's add another method similar to `to`. This time, we'll introduce a `chain` method that accepts a function which takes an iterable and returns another iterable, allowing the result to continue in the `FxIterable` chain. This enables you to dynamically incorporate newly generated iterables directly into your chain, flexibly applying various transformations.

##### [Code 2-54] Adding a chain Method to the FxIterable Class

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator](): Iterator<A> {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...  

  chain<B>(f: (iterable: this) => Iterable<B>): FxIterable<B> {
    return fx(f(this)); // new FxIterable(f(this));
  }
}
```

With `chain`, you can dynamically create any function that takes an iterable and returns a new iterable, extending `FxIterable` at runtime.

##### [Code 2-55] chain + Set

```typescript
const result = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                      // [50, 30, 10, 50, 30]
  .chain(iterable => new Set(iterable))  // Convert to Set, remove duplicates; Set is also iterable
  .reduce((a, b) => a + b); // [FxIterable<number>.reduce<number>(f: ...): number]

console.log(result); // [result: number]
// 90

const result2 = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                      // [50, 30, 10, 50, 30]
  .chain(iterable => new Set(iterable))  // Convert to Set, remove duplicates; Set is also iterable
  .map(n => n - 10)  // [FxIterable<number>.map<number>(f: ...): FxIterable<number>]
  .reduce((a, b) => `${a}, ${b}`);  // [FxIterable<number>.reduce<string>(f: ...): string]

console.log(result2); // [result2: string]
// 40, 20, 0
```

We’ve seen how to combine classes, higher-order functions, iterators, and the type system, integrating tightly with the language to further extend the flexibility of `FxIterable`. By adding the `chain` method, we can dynamically apply any function returning an iterable or convert a collection to another data structure (like a `Set`) and continue chaining. All of this merges naturally with the language, providing type-safe method chaining that integrates well with features like destructuring assignment. Thanks to TypeScript’s type system, type inference works smoothly, letting us perform transformations and continue chaining without needing explicit type declarations.

### The Joy of Extending a Language

The ability for developers to instantly extend a language is perhaps the most appealing feature of metaprogramming. I believe that a crucial turning point, which allowed object-oriented languages to approach the level of metaprogramming in LISP-family languages, was the adoption of first-class functions. Although we could have used interfaces and the iterator pattern in the past, without first-class functions—allowing direct usage of external functions within the iterator—implementing a wide range of functional programming features would have been impossible.

In modern programming languages, first-class functions have only recently been introduced. For example, around 2013, the primary languages for mobile app development—Objective-C (iOS) and Java (Android)—did not support first-class functions. Then in March 2014, Java 8 introduced first-class functions. Then in March 2014, Java 8 introduced first-class functions, but Objective-C ultimately never supported them. Objective-C did introduce “blocks” around 2010, which were a similar feature but quite different from lambda expressions; they had complex variable capture syntax and required manual memory management. Furthermore, blocks were not completely integrated with the standard library or the language’s type system, thus they were strictly limited to sharing contexts in async programming.

- Java introduced first-class functions and the Stream API in Java 8 (2014).
- Swift supported Sequence, Iterator protocols, and first-class functions from its initial release in 2014.
- JavaScript/TypeScript included iterators and generators in ES6 (2015).
- Kotlin has supported first-class functions and iterable-based iteration since its first releases in 2016.
- C# has provided IEnumerable and IEnumerator interfaces from early versions, and introduced many helper functions with LINQ in 2007.

In short, the addition of first-class functions to class-based iterator patterns has led numerous languages to evolve into multiparadigm languages. Moreover, with the introduction of iteration protocols, you can now extend language functionality in a consistent and standardized way. Hence, without modifying language specifications or compilers, developers can organically combine classes, functional higher-order functions, object-oriented patterns, generics, currying, and iterable protocols to achieve sophisticated abstractions and language extension effects.

Of course, TypeScript, Swift, Kotlin, C#, and Java do not provide the same scope or intensity of metaprogramming as LISP-family languages. Yet they still allow for sufficiently rich and high-level abstraction. These modern languages also offer powerful type systems and various object-oriented programming support features, enabling more patterned designs and implementations, and they have established themselves as mainstream languages widely utilized across diverse platforms.

Ultimately, deeply understanding and strategically utilizing the various features in modern multiparadigm languages becomes a powerful weapon for developers. With a solid foundation, developers can approach problems creatively, resulting in effective and extensible solutions.

---

## Navigation

- [Table of Contents](README.md)
- [Prev](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
- [Next](2.4-Summary.md)